Balloon Hunter App 
Functional Specifications Document (FSD)
This document outlines requirements for an iOS application designed to assist a person in hunting and recovering weather balloons. The app's design is centered around a single-screen, map-based interface that provides all critical information in real-time as they pursue a balloon.
1. File Structure
* BalloonHunterApp.swift: App entry. Creates and injects environment objects (BLE, Location, Prediction, Persistence, UserSettings). Handles startup/load.
* AppModels.swift: Core state entities: SondeTelemetry (including parsing, normalization, rolling history, simple stats), LocationData, PredictionData, RouteData, ConnectionStatus, AFCData, UserSettings.
* AppServices.swift: Shared services as ObservableObjects: BLECommunicationService, CurrentLocationService, PredictionService (Sondehub + routing), PersistenceService, AnnotationService. Publish state for views.
* MapView.swift: Main screen: map, markers, polylines (history + prediction), integrates data panel and controls. Consumes environment objects directly.
* DataPanelView.swift: Compact readout of telemetry, route/prediction, connection state, and simple actions (e.g., buzzer). Pure UI bound to environment state.
* SettingsView.swift: Single sheet with internal sections/tabs (Sonde, Radio, Pins, Battery, Prediction, Other). Reads/writes UserSettings, triggers persistence and refresh actions.
* Overlay.swift: Reusable map overlay components and types (annotation items, marker/pin views, polyline helpers) to keep MapView lean.
2. Screen Layout
The application presents a comprehensive overview through a single-screen interface featuring a dynamic map and a dedicated data panel. Here is the design:
2.1. Top Area: Map View
The map starts below the notch, occupying approximately 70% of the vertical space.
2.2. Bottom Area: Info Panel
* Style: Rounded rectangle card
* Layout: Grid (4 columns, multiple rows)
2.3. Settings Menu
The settings menu is placed inside the map at the top left.
2.4. Transport Mode Selector
A selector (car or bicycle) is positioned at the top right of the map.
3. Services
3.1. BLE Communication Service
1. Device Discovery and Connection
   * The service starts right after the app opens.
   * The service actively scans for nearby Bluetooth Low Energy (BLE) devices.
   * It will only attempt to connect to devices whose name includes “MySondyGo”.
   * At any time, the service will maintain a connection to at most one “MySondyGo” device. If a connection is lost, it will attempt to reconnect automatically.
   * BLE Service and Characteristic UUIDs (for Reference):
      * UART Service UUID: 53797269-614D-6972-6B6F-44606C6D6F6E
      * UART RX Characteristic UUID (for receiving data/notifications): 53797269-614D-6972-6B6F-44606C6D6F62
      * UART TX Characteristic UUID (for sending commands/writing): 53797269-614D-6972-6B6F-44606C6D6F61
2. Receiving Data from the Balloon
   * When a connection to a “MySondy” device is established, the device begins transmitting data packets using the Serial BLE protocol as described in the RadioSondyGo Functional Specification Document (FSD).
   * The service is responsible for receiving, buffering, and assembling these packets as they arrive.
3. Packet Parsing and Data Extraction
   * The service parses each incoming BLE packet according to the structure and definitions specified in the RadioSondyGo FSD.
   * Packets representing telemetry data (e.g., the current position, altitude, and movement of the balloon) are extracted and made available to other parts of the app in real time.
   * Packets that contain device settings (identified as “type 3” messages) are extracted and passed directly to the persistence (storage) service for long-term retention.
4. Publishing and Notification
   * The service continuously publishes updates about the connection state (e.g., connected, disconnected, attempting to reconnect), allowing the app’s user interface to reflect the current status.
   * When the first valid telemetry packet is received from a connected device, the service will notify its consumers that RadioSondyGo is “ready for commands” (i.e., it is online and providing balloon data).
5. Reliability and Error Handling
   * If the BLE connection is dropped or interrupted for any reason, the service will attempt to automatically reconnect and resume regular operation.
   * All parsing errors or malformed packets will be safely handled, with the service maintaining stability and attempting to process subsequent packets.
6. Integration with Other Services
   * Telemetry data is published in a manner that allows the application’s map and real-time displays to update instantly as new information about the balloon is received.
   * Device settings data is routed to a dedicated persistence service, which reliably stores this information for retrieval during future connections or app sessions.
3.2. Current Location Service
This service publishes the current position as well as the orientation of the iPhone (particularly its heading to turn a map in the correct orientation).
3.3. Persistence Service
The service handles three types of data:
* Device Settings: The service saves settings that are read from and sent to the RadioSondyGo device. These settings do not need to survive an app closure because their original is on RadioSonyGo. They are stored in a simple key-value store.
* Forecast Settings: It stores specific forecast parameters— burstAltitude (the altitude where the balloon is expected to burst), ascentRate (the rate at which the balloon rises), and descentRate (the rate at which the sonde falls back to Earth). These settings are kept so users don't have to re-enter them each time they open the app. They are stored in a simple key-value store.
* Balloon Track Data: This data, which consists of a historical path of coordinate points for a specific sonde, is managed with a lightweight JSONL structure and is persisted across app closure.
* Balloon Predicted Track Data: This data comes from the Sondehub API and is managed with a lightweight JSONL structure and is not persisted across app closure.
Balloon tracks are persisted under the sondeName. Whenever a new sonde is detected, the data of all previous sondes are deleted. Route data from the Apple Maps service is also temporary and does not need to be persisted when the app closes.
3.4. Balloon Track Prediction Service
The Sondehub balloon path prediction API (https://github.com/projecthorus/tawhiri/) is used to predict:
* The balloon path
* The burst point (Balloon Burst)
* The landing point
This data is used to draw the map overlay and to predict the landing time.
Key parameters for the prediction API call:
* Burst Altitude: During ascent, the default is 35000m (can be changed in settings). If a new telemetry message from the MySondyGo device indicates that the verticalSpeed has a negative value, the “balloonDescends” flag is set. When this flag is set, the burstAltitude parameter to be sent to the API is then automatically set to the current altitude plus 10 meters before the next prediction API call is made. The persistent burst altitude in the settings remains unchanged. For the descent (balloonDescends=true), the burst sign is not shown on the map.
* Ascending Speed: Can be changed in settings, default 5m/s.
* Descending Speed: Can be changed in settings, default 5m/s.
This service is called:
* At the start of the app, after the first telemetry packet is received.
* When the balloon marker in the overlay is pressed with a finger.
* Every 60 seconds, using a timer.
3.5. Route Calculation Service
The route from the current location (the location of the iPhone) to the predicted landing point is calculated by calling Apple Maps. Two modes of transport are selectable (car or bicycle). The track is shown in a map overlay. The predicted arrival time at the landing point is shown in the data panel.
4. Application States
4.1. At the Start of the App
When the app starts, it listens to BLE signals and connects to the first device with the text “MySondy” in its advertised name. After it received and parsed the first BLE message, it sets isReadyForCommands=true. Next, it issues a command to read settings variables from MySondyGo and persists them locally. It also reads the prediction parameters from the persistence store, because they survive the app start, and issues a call to the “Balloon track prediction service”. Next, the long-range tracking state is started.
4.2. Long-Range Tracking State
As said before, the primary interface for long-range tracking is a map view with overlays:
* Map Interaction: The user can zoom and pan the map independently. The overlay must remain accurately positioned and correctly cropped within the displayed map area during these interactions. The zoom level is initially adjusted so that all overlays are visible (user location, balloon track, balloon landing point). Later, the user can change the zoom level.
* Map Overlays:
   * User Position: The iPhone's current GPS position is continuously displayed on the map, represented by a running human figure icon. This position marks the user and is updated automatically as the user moves.
   * Balloon Live Position: The balloon's current real-time position is displayed using a balloon marker. This marker's color indicates data reception status:
      * Green: New telemetry data received within the last 3 seconds.
      * Red: No new data received for more than 3 seconds (marker remains at the last known position).
   * Balloon Track History: The balloon's historical path is drawn on the map as a thin red line.
   * Balloon Track Prediction:
      * Predicted Path: The complete predicted flight path from the Sondehub API is displayed as a thick blue line.
      * Burst Position: While the balloon is ascending, a distinct marker indicates the predicted burst location. The burst marker has to be parsed from the SondeHub KML file. It will be hidden once the balloon is ascending.
      * A new path prediction is triggered:
         * At startup, when the first valid telemetry data is received.
         * Tapping on the balloon marker.
         * Every 60 seconds by an internal timer.
   * User’s Planned Route Overlay: The recommended route from the user's current location to the predicted landing point is fetched from Apple Maps and presented in the map as an overlay (in green). A new route calculation and presentation is triggered after a new prediction is received, and the predicted landing point moves. It is also triggered every minute when the user moves. The transport mode selector (car or bicycle) at the top of the map is used to calculate the route and the predicted arrival time.
4.3. Data Panel
This panel displays the following fields (font sizes adjusted to ensure all data fits within the view without a title):
* Connected: An icon that indicates if a RadioSondyGo is connected via BLE (green), or not (red).
* Buzzer Mute: A button to mute the buzzer must be sized for easy finger pressing. The buzzer can be muted or unmuted by the mute BLE command.
* Sonde Identification: Sonde type, number, and frequency.
* Altitude & Vertical Speed: Current altitude and vertical speed. Green: Ascending, Red: Descending.
* Signal & Battery: Signal strength of the balloon and the battery status of RadioSondyGo in percentage.
* Time Estimates: Predicted balloon landing time (from prediction service) and user arrival time (from routing service), both displayed in wall clock time for the current time zone. These times are updated with each new prediction or route calculation.
* Remaining Balloon Flight Time: Time in hours:minutes from now to the predicted landing time.
* Distance: The distance of the calculated route in kilometers (from route calculation).
Layout:
Column 1
	Column 2
	Column 3
	Column 4
	Connected
	Sonde Type
	sondeName
	Mute
	

	Frequency
	Signal Strength
	Battery %
	

	Altitude
	Horizontal Speed
	Vertical Speed
	Distance
	Landing time
	Flight time
	Arrival Time
	Spacing and Font: Data has to fit the available space. Column 1 is very narrow.
4.4. Final Approach State
This phase is used when the balloon has landed and the user is near the balloon. A new behavior of the screen is needed for this phase. No data panel is needed anymore. The map covers the entire screen below the notch.
Triggers for this phase:
* The balloon's vertical speed is less than 1m/s for the last 10 telemetry data points and
* The user (Current location service) is within 1km of the balloon's last telemetry position.
4.5. Map View & Overlays During Final Approach Phase
In Final Approach mode, the map's behavior changes to prioritize short-range navigation. The app will:
* Display a Stable Position for the Balloon (balloonLandedPosition): An additional marker will appear on the map, representing the averaged position of the telemetry positions after the balloon is landed. Only the newest maximal 100 balloon telemetry coordinates are used (simple average). This provides a more stable and accurate target for the user.
* Orient the Map for Directional Cues: The map's orientation will automatically adjust based on the iPhone's compass. The iPhone’s current location will be fixed at the bottom-center of the screen. The map will then rotate so that its direction is synchronized with the iPhone's direction.
* Zoom: The iPhone and the additional marker (balloonLandedPosition) are always visible, and the map has maximal resolution.
5. Settings
5.1. Settings View
This view should use a modern, three-button navigation system in the top-left corner of the map view.
* A balloon that opens a window to change the sonde type and frequency.
* A wrench that opens a settings window with 5 tabs: Pins, Battery, Radio, Prediction, and Others.
* A button for “Tune” that opens the Tune view.
5.2. Sonde Settings Window (Balloon icon)
When opened, this window will display the currently configured sonde type and frequency, allowing the user to change them. If no valid data is available (isReadyForCommands is false), a message is displayed instead (Sonde not connected). A "Save" button specific to this window will be present to trigger the update function for these settings. A BLE message to set the sonde type and its frequency “o{f=frequency/tipo=probeType}o” according to the MySondyGo specs has to be sent.
5.3. Device Settings (Wrench)
The persistence service persists all settings. The single source of truth for sonde settings data is stored on the MySondyGo device and is only displayed and changed in the app. Therefore, we use the following process:
We use a key-value store. The process would be as follows:
* After isReadyForCommands=true, the app requests the current settings from MySondyGo.
* MySondyGo responds with a Type 3 configuration message.
* The app's BLE service parses this message and stores the settings in a key-value store.
* This data then serves as the local cache. The app's views display the settings directly from this cache.
* If a user modifies a setting, the change is first applied to the local cache. This provides immediate feedback in the UI.
* A BLE command with the changed parameters is then sent to the MySondyGo device to update the MySondyGo.
* Upon reconnection, the app repeats the process of reading the settings from the device and updating the local cache to ensure synchronization.
5.4. Change Device Settings
Device settings can be changed through a settings view. When settings are changed (the save button is pressed), they must be persisted to the local cache and sent with particular BLE commands to the MySondygo device.
5.5. Initialization & Data Refresh
When the Settings sheet is presented:
* The app sends an o{?}o command via the BLE service to request a Type-3 message (device configuration report).
* If a Type-3 message is received within a short timeout (e.g., 2–3 seconds), the form fields are populated with the most recent values from the MySondyGo device.
* If no Type-3 response arrives, the sheet displays “Sonde not connected”, and all device-related fields remain empty and disabled.
* Prediction settings are always loaded from the app’s local persistence (they never depend on the device).
5.6. Tab Structure & Contents
Each tab contains logically grouped settings:
5.6.1. Pins Tab
* oled_sda (oledSDA)
* oled_scl (oledSCL)
* oled_rst (oledRST)
* led_pout (ledPin)
* buz_pin (buzPin)
* lcd (lcdType)
5.6.2. Battery Tab
* battery (batPin)
* vBatMin (batMin)
* vBatMax (batMax)
* vBatType (batType)
5.6.3. Radio Tab
* myCall (callSign)
* rs41.rxbw (RS41Bandwidth)
* m20.rxbw (M20Bandwidth)
* m10.rxbw (M10Bandwidth)
* pilot.rxbw (PILOTBandwidth)
* dfm.rxbw (DFMBandwidth)
5.6.4. Others Tab
* lcdOn (lcdStatus)
* blu (bluetoothStatus)
* baud (serialSpeed)
* com (serialPort)
* aprsName (aprsName / nameType)
5.6.5. Prediction Tab
(These values are stored permanently on the iPhone via PersistenceService and are never transmitted to the device)
* burstAltitude
* ascentRate
* descentRate
5.7. User Actions
5.7.1. Cancel
* Discards all changes made in the sheet.
* Closes the sheet without sending any BLE commands or modifying persistence.
5.7.2. Save
* Prediction Tab values are immediately persisted locally.
* All other fields are bundled into BLE commands and sent to the mySondyGo device sequentially.
* The sheet closes only once the Save sequence is completed.
5.8. Tuning Function
The "TUNE" function in MySondyGo is a calibration process designed to compensate for frequency shifts of the receiver. These shifts can be several kilohertz (KHz) and impact reception quality. The tune view shows a moving average of the AFC values (freqofs) across the last 20 messages received from MyRadiosondyGo. If we press the “save” button, the actual value is stored using the setFreqCorrection command. The view stays open to check the effect. Only after pressing “cancel” is the view closed.
6. Architecture
We use @Environment and @EnvironmentObject to share state and services across views. This approach avoids boilerplate ViewModels and allows views to bind directly to application state, making the app lightweight and reactive.
* AppState (ObservableObject): Coarse global flags (e.g., isReadyForCommands, current phase/mode).
* TelemetryState (ObservableObject): Live sonde telemetry + AFC data.
* LocationState (ObservableObject): iPhone + balloon location/heading.
* PredictionState (ObservableObject): Predicted path, burst, landing.
* RouteState (ObservableObject): Route polyline, distance, ETA.
* UserSettings (ObservableObject): Device pins, radio/bandwidth, forecast params; persisted via PersistenceService.
6.1. Views (User Interface)
Views directly bind to @EnvironmentObject models. They present data reactively and call methods on the injected objects for actions (instead of delegating to a ViewModel).
* MapView: Main screen showing map, user marker, balloon, history, prediction overlays, burst & landing points. Includes transport mode selector + navigation controls.
* DataPanelView: Displays telemetry values, route distances, times, and buzzer control.
* SondeSettingsView: Sheet for selecting sonde type and frequency.
* SystemSettingsView: Tabbed sheet (PinsSettingsTab, BatterySettingsTab, RadioSettingsTab, PredictionSettingsTab, OtherSettingsTab).
* TuneView: Displays AFC values and allows correction adjustments.
* NotificationBannerView: Reusable transient component. Binds to a shared Notifications model in the environment.
6.2. System and Environment Information
There are some technical details and assumptions that need to be clarified.
* iOS Compatibility: iOS 18.
* Error Handling: Malformed packets will be "safely handled". Missing data will be announced with a pop-up.
* Permissions: Bluetooth, Location Services.
7. Data Structures (Models)
The application defines several important data structures to represent its domain:
* DeviceSettings: Represents the detailed configuration parameters of the sonde device (e.g., sondeType, frequency, oledSDA, callSign, threshold). It has a static var default for initial values.
* AppSettings: A simple ObservableObject singleton that holds the current Settings and provides a mechanism to update them globally.
* PredictionInfo: A class intended to hold prediction-related data that can be shared across the app (e.g., landingTime, arrivalTime, routeDistanceMeters).
* TelemetryData: A comprehensive class representing a single telemetry data point from the sonde, including latitude, longitude, altitude, signalStrength, batteryPercentage, and firmwareVersion. It includes parsing methods.
* TelemetryTransferData: A struct that serves as a lightweight, serializable representation of telemetry data to directly persist telemetry data.
* SondeSettingsTransferData: A Codable and Equatable struct used for representing the settings received from or sent to the BLE device.
* MapAnnotations: A Identifiable struct used to represent markers on the map. It includes coordinate, kind (e.g., .user, .balloon), and status (e.g., .fresh, .stale), and a @ViewBuilder for its visual representation.
* TransportationMode: A simple enum (.car, .bike) to represent the user's preferred mode of transport for route calculations.
Appendix: 
A.1 Messages from RadioSondyGo
A.1.1 Type 0 (No probe received)
* Format: 0/probeType/frequency/RSSI/batPercentage/batVoltage/buzmute/softwareVersion/o
* Example: 0/RS41/403.500/117.5/100/4274/0/3.10/o
* Field Count: 7 fields
* Values:
   * probeType: e.g., RS41
   * frequency: e.g., 403.500 (MHz)
   * RSSI: e.g., -90 (dBm)
   * batPercentage: e.g., 100 (%)
   * batVoltage: e.g., 4000 (mV)
   * buzmute: e.g., 0 (0 = off, 1 = on)
   * softwareVersion: e.g., 3.10
A.1.2. Type 1 (Probe telemetry)
* Format: 1/probeType/frequency/sondeName/latitude/longitude/altitude/HorizontalSpeed/verticalSpeed/RSSI/batPercentage/afcFrequency/burstKillerEnabled/burstKillerTime/batVoltage/buzmute/reserved1/reserved2/reserved3/softwareVersion/o
* Example: 1/RS41/403.500/V4210150/47.38/8.54/500/10/2/117.5/100/0/0/0/4274/0/0/0/0/3.10/o (Example values for dynamic fields added for clarity)
* Field Count: 20 fields
* Variable names:
   * probeType: e.g., RS41
   * frequency: e.g., 403.500 (MHz)
   * sondeName: e.g., V4210150
   * latitude: (dynamic) e.g., 47.38 (degrees)
   * longitude: (dynamic) e.g., 8.54 (degrees)
   * altitude: (dynamic) e.g., 500 (meters)
   * horizontalSpeed: (dynamic) e.g., 10 (m/s)
   * verticalSpeed: (dynamic) e.g., 2 (m/s)
   * RSSI: e.g., -90 (dBm)
   * batPercentage: e.g., 100 (%)
   * afcFrequency: e.g., 0
   * burstKillerEnabled: e.g., 0 (0 = disabled, 1 = enabled)
   * burstKillerTime: e.g., 0 (seconds)
   * batVoltage: e.g., 4000 (mV)
   * buzmute: e.g., 0 (0 = off, 1 = on)
   * reserved1: e.g., 0
   * reserved2: e.g., 0
   * reserved3: e.g., 0
   * softwareVersion: e.g., 3.10
A.1.3. Type 2 (Name only, coordinates are not available)
* Corrected Format: 2/probeType/frequency/sondeName/RSSI/batPercentage/afcFrequency/batVoltage/buzmute/softwareVersion/o
* Example: 2/RS41/403.500/V4210150/117.5/100/0/4274/0/3.10/o
* Field Count: 10 fields
* Variable names:
   * probeType: e.g., RS41
   * frequency: e.g., 403.500 (MHz)
   * sondeName: e.g., V4210150
   * RSSI: e.g., -90 (dBm)
   * batPercentage: e.g., 100 (%)
   * afcFrequency: e.g., 0
   * batVoltage: e.g., 4000 (mV)
   * buzmute: e.g., 0 (0 = off, 1 = on)
   * softwareVersion: e.g., 3.10
A.1.4. Type 3 (Configuration)
* Format: 3/probeType/frequency/oledSDA/oledSCL/oledRST/ledPin/RS41Bandwidth/M20Bandwidth/M10Bandwidth/PILOTBandwidth/DFMBandwidth/callSign/frequencyCorrection/batPin/batMin/batMax/batType/lcdType/nameType/buzPin/softwareVersion/o
* Example: 3/RS41/404.600/21/22/16/25/1/7/7/7/6/MYCALL/0/35/2950/4180/1/0/0/0/3.10/o
* Field Count: 21 fields
* Variable names:
   * probeType: e.g., RS41
   * frequency: e.g., 404.600 (MHz)
   * oledSDA: e.g., 21 (GPIO pin number)
   * oledSCL: e.g., 22 (GPIO pin number)
   * oledRST: e.g., 16 (GPIO pin number)
   * ledPin: e.g., 25 (GPIO pin number)
   * RS41Bandwidth: e.g., 1 (kHz)
   * M20Bandwidth: e.g., 7 (kHz)
   * M10Bandwidth: e.g., 7 (kHz)
   * PILOTBandwidth: e.g., 7 (kHz)
   * DFMBandwidth: e.g., 6 (kHz)
   * callSign: e.g., MYCALL
   * frequencyCorrection: e.g., 0 (Hz)
   * batPin: e.g., 35 (GPIO pin number)
   * batMin: e.g., 2950 (mV)
   * batMax: e.g., 4180 (mV)
   * batType: e.g., 1 (0:Linear, 1:Sigmoidal, 2:Asigmoidal)
   * lcdType: e.g., 0 (0:SSD1306_128X64, 1:SH1106_128X64)
   * nameType: e.g., 0
   * buzPin: e.g., 0 (GPIO pin number)
   * softwareVersion: e.g., 3.10
A.2. Data Types
A.2.1. Type 0 Packet: Device Basic Info and Status
* 0: packet type (String) - "0"
* 1: probeType (String)
* 2: frequency (Double)
* 3: RSSI (Double)
* 4: batPercentage (Int)
* 5: batVoltage (Int)
* 6: buzmute (Bool, 0 = off, 1 = on)
* 7: softwareVersion (String)
A.2.2. Type 1 Packet: Probe Telemetry
* 0: packet type (Int) - "1"
* 1: probeType (String)
* 2: frequency (Double)
* 3: sondeName (String)
* 4: latitude (Double)
* 5: longitude (Double)
* 6: altitude (Double)
* 7: horizontalSpeed (Double)
* 8: verticalSpeed (Double)
* 9: RSSI (Double)
* 10: batPercentage (Int)
* 11: afcFrequency (Int)
* 12: burstKillerEnabled (Bool, 0 = disabled, 1 = enabled)
* 13: burstKillerTime (Int)
* 14: batVoltage (Int)
* 15: buzmute (Bool, 0 = off, 1 = on)
* 16: reserved1 (Int)
* 17: reserved2 (Int)
* 18: reserved3 (Int)
* 19: softwareVersion (String)
A.2.3. Type 2 Packet: Name Only
* 0: packet type (Int) - "2"
* 1: probeType (String)
* 2: frequency (Double)
* 3: sondeName (String)
* 4: RSSI (Double)
* 5: batPercentage (Int)
* 6: afcFrequency (Int)
* 7: batVoltage (Int)
* 8: buzmute (Bool, 0 = off, 1 = on)
* 9: softwareVersion (String)
A.2.4. Type 3 Packet: Configuration
* 0: packet type (Int) - "3"
* 1: probeType (String)
* 2: frequency (Double)
* 3: oledSDA (Int)
* 4: oledSCL (Int)
* 5: oledRST (Int)
* 6: ledPin (Int)
* 7: RS41Bandwidth (Int)
* 8: M20Bandwidth (Int)
* 9: M10Bandwidth (Int)
* 10: PILOTBandwidth (Int)
* 11: DFMBandwidth (Int)
* 12: callSign (String)
* 13: frequencyCorrection (Int)
* 14: batPin (Int)
* 15: batMin (Int)
* 16: batMax (Int)
* 17: batType (Int)
* 18: lcdType (Int)
* 19: nameType (Int)
* 20: buzPin (Int)
* 21: softwareVersion (String)
A.2 RadioSondyGo Commands
All commands sent to the RadioSondyGo device must be enclosed within o{...}o delimiters. You can send multiple settings in one command string, separated by /, or send them individually.
A.2.1 Settings Command
This command is used to configure various aspects of the RadioSondyGo device. All settings are stored for future use.
* Syntax: o{setting1=value1/setting2=value2/...}o
* Examples:
   * o{lcd=0/blu=0}o (Sets LCD driver to SSD1306 and turns Bluetooth off)
   * o{f=404.600/tipo=1}o (Sets frequency to 404.600 MHz and probe type to RS41)
   * o{myCall=MYCALL}o (Sets the call sign displayed to MYCALL)
Available Settings:
Variable Name
	Description
	Default Value
	Reboot Required
	lcd
	Sets the LCD driver: 0 for SSD1306_128X64, 1 for SH1106_128X64.
	0
	Yes
	lcdOn
	Turns the LCD on or off: 0 for Off, 1 for On.
	1
	Yes
	oled_sda
	Sets the SDA OLED Pin.
	21
	Yes
	oled_scl
	Sets the SCL OLED Pin.
	22
	Yes
	oled_rst
	Sets the RST OLED Pin.
	16
	Yes
	led_pout
	Sets the onboard LED Pin; 0 switches it off.
	25
	Yes
	buz_pin
	Sets the buzzer Pin: 0 for no buzzer installed, otherwise specify the pin.
	0
	Yes
	myCall
	Sets the call shown on the display (max 8 characters). Set empty to hide.
	MYCALL
	No
	blu
	Turns BLE (Bluetooth Low Energy) on or off: 0 for off, 1 for on.
	1
	Yes
	baud
	Sets the Serial Baud Rate: 0 (4800), 1 (9600), ..., 5 (115200).
	1
	Yes
	com
	Sets the Serial Port: 0 for tx pin 1 – rx pin 3 – USB, 1 for tx pin 12 – rx pin 2 (3.3V logic).
	0
	Yes
	rs41.rxbw
	Sets the RS41 Rx Bandwidth (see bandwidth table below).
	4
	No
	m20.rxbw
	Sets the M20 Rx Bandwidth (see bandwidth table below).
	7
	No
	m10.rxbw
	Sets the M10 Rx Bandwidth (see bandwidth table below).
	7
	No
	pilot.rxbw
	Sets the PILOT Rx Bandwidth (see bandwidth table below).
	7
	No
	dfm.rxbw
	Sets the DFM Rx Bandwidth (see bandwidth table below).
	6
	No
	aprsName
	Sets the Serial or APRS name: 0 for Serial, 1 for APRS NAME.
	0
	No
	freqofs
	Sets the frequency correction.
	0
	No
	battery
	Sets the battery measurement Pin; 0 means no battery and hides the icon.
	35
	Yes
	vBatMin
	Sets the low battery value (in mV).
	2950
	No
	vBatMax
	Sets the battery full value (in mV).
	4180
	No
	vBatType
	Sets the battery discharge type: 0 for Linear, 1 for Sigmoidal, 2 for Asigmoidal.
	1
	No
	A.2.2 Bandwidth Table:
Value
	Bandwidth (kHz)
	0
	2.6
	1
	3.1
	2
	3.9
	3
	5.2
	4
	6.3
	5
	7.8
	6
	10.4
	7
	12.5
	8
	15.6
	9
	20.8
	10
	25.0
	11
	31.3
	12
	41.7
	13
	50.0
	14
	62.5
	15
	83.3
	16
	100.0
	17
	125.0
	18
	166.7
	19
	200.0
	A.2.3. Frequency Command (sent separately)
This command sets the receiving frequency and the type of radiosonde probe to listen for.
* Syntax: o{f=frequency/tipo=probeType}o
* Example: o{f=404.35/tipo=1}o (Sets frequency to 404.35 MHz and probe type to RS41)
Available Sonde Types for commands (tipo):
* 1: RS41
* 2: M20
* 3: M10
* 4: PILOT
* 5: DFM
A.2.4. Mute Command
This command controls the device's buzzer.
* Syntax: o{mute=setMute}o
* Variable:
   * setMute: 0 for off, 1 for on.
* Example: o{mute=0}o (Turns the buzzer off)
A.2.5. Request Status Command
This command requests the current status and configuration of the RadioSondyGo device.
* Syntax: o{?}o
A.3 Sample Response of the Sondehub API
<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
<name>Flight Path</name>
<description>Flight Data for start time 2025-08-05T06:40:13Z, at site: 46.9046,7.3112, standard flight profile.</description>
<Style id="yellowPoly">
<LineStyle>
<color>7f00ffff</color>
<width>4</width>
</LineStyle>
<PolyStyle>
<color>7f00ff00</color>
</PolyStyle>
</Style>
<Placemark>
<name>Flight path</name>
<description>Ascent rate: 5.0, descent rate: 5.0, with burst at 35001.0m.</description>
<styleUrl>#yellowPoly</styleUrl>
<LineString>
<extrude>1</extrude>
<tesselate>1</tesselate>
<altitudeMode>absolute</altitudeMode>
<coordinates>
7.31120,46.90460,847.0
7.31356,46.90561,1147.0
7.31710,46.90654,1447.0
7.32157,46.90740,1747.0
7.32686,46.90838,2047.0
7.33283,46.90958,2347.0
7.33930,46.91106,2647.0
......
7.84781,47.00683,4166.2
7.85786,47.00851,3800.8
7.86746,47.01072,3442.2
7.87675,47.01312,3090.2
7.88572,47.01525,2744.5
7.89398,47.01692,2404.7
7.90109,47.01820,2070.7
7.90665,47.01912,1742.3
7.91087,47.01977,1419.1
7.91419,47.02022,1101.0
7.91531,47.02032,951.8

</coordinates>
</LineString></Placemark>

<Placemark>
<name>Balloon Launch</name>
<description>Balloon launch at 46.90460,7.31120, at 2025-08-05T06:40:13Z.</description>
<Point><altitudeMode>absolute</altitudeMode><coordinates>7.31120,46.90460,847.0</coordinates></Point>
</Placemark>

<Placemark>
<name>Balloon Burst</name>
<description>Balloon burst at 46.97372,7.52491, at 2025-08-05T08:34:04.09375Z.</description>
<Point><altitudeMode>absolute</altitudeMode><coordinates>7.52491,46.97372,35002.5</coordinates></Point>
</Placemark>

<Placemark>
<name>Balloon Landing</name>
<description>Balloon landing at 47.02032,7.91531, at 2025-08-05T09:18:32.6875Z.</description>
<Point><altitudeMode>absolute</altitudeMode><coordinates>7.91531,47.02032,951.8</coordinates></Point>
</Placemark>

</Document></kml>